# -*- coding: utf-8 -*-
"""Zero Lag Correlations

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uhf3iyVub8l7zInTXlNhCp3EmlI_x0hO
"""

# prompt: Make two arrays with binary 0 1 values randomly

import numpy as np
import matplotlib.pyplot as plt

# Create two arrays with random binary values
array1 = np.random.randint(2, size=200) # Example size of 10
array2 = np.random.randint(2, size=200) # Example size of 10
array3 = np.roll(array1,5) #just time delay

# assume a certain "speed limit" in units of samples

"""# Zero-Lag Correlations May Be Real
Had a recent discussion talking about zero-lag correlations with neural recordings.
The current thinking seems to be that all zero-lag correlation is spurious - a reflection of "faster than light" causal influence or just quantified happenstance.

I like to play Devil's Advocate: is there a way we can make zero-lag correlations meaningful?

In this post, I set up a simple signal model with a known "causal link" between two signals.
I then show how non-trivial convolution with tailed functions can induce zero-lag correlation - and that correlation seems to unreliably reflect causal ground truths.
"""

plt.stem(array1, label='Array 1',linefmt='r')
plt.stem(array2, label='Array 2',linefmt='g')
plt.stem(array3, label='Array 3',linefmt='b')
plt.legend()
plt.show()

# prompt: Calculate the correlation between all two arrays

import numpy as np
from itertools import combinations

corr_coeffs_arrays = []
corr_stats = []

for first_array, second_array in list(combinations([array1,array2,array3],2)):
  correlation_matrix = np.corrcoef(first_array, second_array)
  correlation_coefficient = correlation_matrix[0, 1]
  corr_p_val = correlation_matrix[1,1]
  print(f"Correlation coefficient between arrays: {correlation_coefficient}")
  corr_coeffs_arrays.append(correlation_coefficient)

# prompt: now convolve each array with a heavy tail decay function

import matplotlib.pyplot as plt
import numpy as np
# Define a heavy-tail decay function (e.g., Cauchy or similar)
def heavy_tail_decay(x, alpha=2, beta=2):
  """A heavy-tail decay function (Cauchy-like)."""
  return beta / (beta**2 + x**alpha)

def dirac_delta(x):
  out = np.zeros_like(x)
  x_len = out.shape[0]
  out[x_len//2-1] = 1 #for some reason need the -1 in the index
  return out

# Create the heavy-tail kernel
kernel_size = 20 # Example kernel size
kernel = heavy_tail_decay(np.arange(-kernel_size // 2, kernel_size // 2))
kernel[0:10] = 0

#kernel = dirac_delta(np.arange(-kernel_size // 2, kernel_size // 2))
plt.stem(kernel)

# Convolve each array with the heavy-tail kernel
convolved_array1 = np.convolve(array1, kernel, mode='same')
convolved_array2 = np.convolve(array2, kernel, mode='same')
convolved_array3 = np.convolve(array3, kernel, mode='same')

# Plot the original and convolved arrays
plt.figure(figsize=(10, 6))

plt.subplot(2, 1, 1)
plt.stem(array1, label='Original Array 1',linefmt='r')
plt.stem(array2, label='Original Array 2',linefmt='g')
plt.stem(array3, label='Original Array 3',linefmt='b')
plt.title('Original Arrays')
plt.legend()

plt.subplot(2, 1, 2)
plt.plot(convolved_array1, label='Convolved Array 1', color='r')
plt.plot(convolved_array2, label='Convolved Array 2', color='g')
plt.plot(convolved_array3, label='Convolved Array 3', color='b')
plt.title('Convolved Arrays (with Heavy-Tail Decay)')
plt.legend()

plt.tight_layout()
plt.show()

# Calculate correlation coefficients for convolved arrays
print("\nCorrelation coefficients after convolution:")
combo_labels = list(combinations(['array1','array2','array3'],2))
for ii, (conv_array1, conv_array2) in enumerate(list(combinations([convolved_array1, convolved_array2, convolved_array3], 2))):
    correlation_matrix_conv = np.corrcoef(conv_array1, conv_array2)
    correlation_coefficient_conv = correlation_matrix_conv[0, 1]
    print(f"Original arrays {combo_labels[ii]}: {corr_coeffs_arrays[ii]} -> Kernel-Convolved arrays: {correlation_coefficient_conv}")

#Let's run the above experiment 100 times and get a distribution for the three correlations of interest...
# Hypothesis is that the distribution of array1->array3 will be higher, given we know there's a causal link between the two with the "roll" function