# -*- coding: utf-8 -*-
"""Delay-Corr

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zp9u24dy41Bfei-FiltkIK8XWUliRaZ4

# Exploring Coupling with Nodal Delays

one of the key factors that gets ignored the most in neuroscience is *delay*.
That is, when two neurons are connected, we tend to ignore the fact that there's a time gap between one firing and a downstream neuron firing.
When we're looking at just two neurons, this isn't a big deal - it's often *negligible* with respect to the behavior we care about.

But when we start looking at large-scale networks, these delays could very well add up.

In this post, I want to do a quick dive into how *delays* can affect a common pairwise measure used across neural recording/imaging: the **correlation**.
"""

#@title Setup and Classes
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt

class vox_pair:
  def __init__(self, snr = 1, delay = np.pi/2, noise = None, plotting = True, samples = 100, damping = 1.0, shift = None, sig_diff = 1.0):
    self.sig = snr
    self.delay = delay
    self.noise = noise
    self.damping = damping
    self.shift = shift
    self.sig_diff = sig_diff

    self.signal = None
    self._global_plotting = plotting

    self._x = np.linspace(0,10,samples)

  def gen_signal(self):
    sig = self.sig
    delay = self.delay
    noise = self.noise
    damping_factor = self.damping
    sig_diff = self.sig_diff

    x = self._x

    y1 = sig * np.exp(-damping_factor * x) * np.sin(x * 2 * np.pi * 0.5)
    y2 = sig_diff * sig * np.exp(-damping_factor * x) * np.sin(x * 2 * np.pi * 0.5 + delay)

    if self.shift is not None:
      y2 = np.roll(y2,int(self.shift))
      y2[:int(self.shift)] = 0
    self.clean_signal = {'y1':np.copy(y1), 'y2':np.copy(y2)}

    # add noise here
    if noise is not None:
      y1 += np.random.normal(0,noise,y1.shape)
      y2 += np.random.normal(0,noise,y2.shape)

    self.signal = {'y1':y1, 'y2':y2}

    return self

  def plot_signal(self, plot_clean = False):
    if self.signal is not None:
      if self._global_plotting:

        y1 = self.signal['y1']
        y2 = self.signal['y2']
        x = self._x

        fig, (ax1, ax2) = plt.subplots(1, 2, sharex=False)
        ax1.plot(x,y1,alpha=0.5)
        ax1.plot(x,y2,alpha=0.5)

        if plot_clean:
          cy1 = self.clean_signal['y1']
          cy2 = self.clean_signal['y2']
          ax1.plot(x,cy1)
          ax1.plot(x,cy2)
          ax1.set_title(f"$\delta$: {self.delay}")

        ax2.scatter(y1,y2)
        plt.show()
    else:
      print("No signal to plot")
    return self

  def do_stats(self, standard_print = True):
    y1 = self.signal['y1']
    y2 = self.signal['y2']

    # do stats here
    do_stats = {'spearmanr': {'function': stats.spearmanr, 'result': []}, 'pearsonr': {'function': stats.pearsonr, 'result': []}}

    for do_stat in do_stats.keys():
        do_stats[do_stat]['result'] = do_stats[do_stat]['function'](y1,y2)
        if standard_print:
          print(f"{do_stat}: {do_stats[do_stat]['result']}")

    return {stat: stat_result['result'] for stat,stat_result in do_stats.items()}

"""## Simple Signal Model
We'll start with a very simple *signal model* - contrasting with a generative or dynamical model.
The signal model cares just about high-level features of a signal, and not necessarily processes that generate those features.

We'll set up two signals, corresponding to two "voxels", where each signal has...
"""

snr, delay, damping, shift = 5, None, 0, 0

delay_stats = []
delay_list = np.linspace(0,np.pi,10)
for delay in delay_list:
  sys = vox_pair(snr = snr, delay = delay, noise = 1, plotting=True, samples=100, damping=damping, shift = shift, sig_diff = 1.0)
  delay_stats.append(sys.gen_signal().plot_signal(plot_clean = True).do_stats(standard_print = False))

all_p_val = [res['spearmanr'][1] for res in delay_stats]
all_corr_val = [res['spearmanr'][0] for res in delay_stats]

fig, ax1 = plt.subplots(1, 1, sharex=True)

ax1.plot(delay_list,all_p_val, color='red');
ax1.axhspan(0, 0.05, color="orange", alpha=0.1)
ax1.set_ylabel('p-value', color='red')  # we already handled the x-label with ax1
ax1.tick_params(axis='y', labelcolor='red')
ax2 = ax1.twinx()
ax2.plot(delay_list,all_corr_val, color='blue');
ax2.set_ylabel('Correlation', color='blue')  # we already handled the x-label with ax1
ax2.tick_params(axis='y', labelcolor='blue')

ax1.set_ylim((0,1.))
ax1.set_xlabel('Phase Delay (radians)')
plt.show()
#sys = vox_pair(snr = 10, delay = 0*np.pi/2, noise = 1)
#sys.gen_signal().plot_signal().do_stats()

"""Instant-Opposite? Or Delayed-Same?

TODO: Analyse Fox

## Synthetic Brain
"""

# let's make an NxNxN "brain"
D = 1
N = 3

rvec = np.zeros((N,N,N,D))

#let's make a connectivity between the NxNxN nodes
import networkx as nx

brain_g = nx.erdos_renyi_graph(N**3,0.2)
#TODO sanity check to ensure only 1 community
nx.draw(brain_g)

# we want to generate a multivariate normal instance using the graph Laplacian as the covariance
data = np.random.multivariate_normal(0 * np.zeros(N**3), cov = nx.laplacian_matrix(brain_g))